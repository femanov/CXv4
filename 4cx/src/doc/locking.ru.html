<HTML>
<HEAD>
<TITLE>Блокировка каналов в CXv4, версия 1</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="style.css">
</HEAD>
<BODY>

<H1>Блокировка каналов в CXv4, версия 1</H1>

	<H2>Введение</H2>

<P>В этом манускрипте кратко описывется реализация возможности блокировки
каналов в CXv4 по состоянию на май 2020 года.

<P>Это довольно простая модель, обеспечивающая лишь блокировку на запись
(блокировки чтения не предусмотрено).  Система контроля права наложения
блокировки также простейшая, по принципу &laquo;кто первый попросит, тот и
получит&raquo;, без разделения прав по именам юзеров или по-канального
разрешения/запрещения блокировки (но возможен запрет блокирования на уровне
системы контроля доступа, по IP-адресам клиентов&nbsp;&#151; режим доступа
<TT>nolock</TT>).

<P>Текущая реализация является первоначальной и не претендует на
идеальность.  Предполагается доработать её по результатам испытаний (а
возможно, придётся и полностью переработать).


	<H2>Общее описание</H2>

		<H3>Постановка задачи</H3>

<P>В некоторых применениях требуется захватывать каналы записи для
монопольного управления, чтобы захватившая программа могла производить
некоторую последовательность действий с полной уверенностью, что в этот
процесс не вмешается другая программа.

<P>Т.е., требуется:

  <OL>

  <LI>Накладывать блокировку записи (exclusive write lock).

  <LI>Блокировать требуется НАБОРЫ каналов, в т.ч. могущих относиться к
нескольким разным серверам.

  </OL>


		<H3>Идеологическая проблема</H3>

<P>Во-первых, гарантированное обеспечение синхронного наложения блокировки
на нескольких серверах&nbsp;&#151; практически неразрешимая задача.

<P>Во-вторых, наложение блокировки идеологически сильно отличается от
основных операций системы управления&nbsp;&#151; чтения и записи:

  <UL TYPE=square>

  <LI>Чтение и запись могут быть реализованы в распределённой системе
асинхронно с минимальными отступлениями от сиххронной модели
(чтение&nbsp;&#151; путём подписки, запись&nbsp;&#151; отказом от ожидания
завершения (т.е., от подтверждения)).

  <LI>Наложение же блокировки&nbsp;&#151; принципиально
&laquo;синхронная&raquo; операция, поскольку требует подтверждения её
исполнения для возможности дальнейших действий с блокируемыми каналами.

  </UL>


		<H3>Выбранная парадигма</H3>

<P>Идея заключается в том, что эта синхронная операция декомпозирована на
набор асинхронных, которые в сумме позволяют получить тот же результат.  А
именно:

  <UL TYPE=square>

  <LI>Сама операция "наложить блокировку" является лишь ЗАПРОСОМ&nbsp;&#151;
она показывает желание программы получить канал в монопольное управление, но
НЕ гарантирует исполнение этого требования.

  <LI>Существует по-канальное событие &laquo;изменение статуса
заблокированности&raquo; (LOCKSTAT), могущее быть получено в любой момент и
сообщающее о получении блокировки канала либо о её потере.

  <LI>Также программа может в любой момент запросить у cda текущее последнее
известное состояние заблокированности канала.

  </UL>

<P>Таким образом, когда программе требуется получить некоторый набор каналов
в монопольное управление, то следует:

  <OL>

  <LI>Установить блокировку:

    <UL TYPE=square>

    <LI>Вызвать запрос наложения блокировки на эту группу
каналов&nbsp;&#151; <CODE>cda_lock_chans()</CODE> с кодом операции
<CODE>CX_LOCK_WRITE_SET</CODE>.

    <LI>Дождаться, когда будут получены положительные уведомления LOCKSTAT на
все каналы набора.

    <LI>(Для упрощения проверки можно вместо собственного подсчёта &laquo;на
все ли каналы были получены подтверждения&raquo; пользоваться вызовом
<CODE>cda_lock_stat_of_ref()</CODE>, проверяя заблокированность на текущий
момент.)

    </UL>

  <LI>Произвести последовательность действий, требующих монопольного
доступа.

  <LI>Снять блокировку каналов, вызовом той же
<CODE>cda_lock_chans()</CODE>, но с кодом операции
<CODE>CX_LOCK_WRITE_RLS</CODE>.

  </OL>

  <UL TYPE=square>

  <LI>Также программа должна быть готова в любой момент к получению
отрицательного уведомления LOCKSTAT, свидетельствующего о потере
монопольного доступа.

<P>Это уведомление присылается не только при добровольном снятии блокировки
(как подтверждение исполнения), но и, например, при потере соединения с
сервером.

<P>При получении такого уведомления очевидным образом следует прервать
последовательность действий, требующих монопольного доступа.

  </UL>


		<H3>Ограничения</H3>

  <UL TYPE=square>

  <LI>Самое главное ограничение&nbsp;&#151; нет ГАРАНТИЙ получения
блокировки.  Даже полученная блокировка может в любой момент быть потеряна. 
Это неизбежное следствие распределённости системы управления.

<P>(Хотя блокировки по протоколу insrv:: (междрайверные в рамках одного
сервера) являются по сути локальными и гарантируют устойчивость, с оговоркой
о возможности убиения или падения сервера целиком.)

  <LI>Отсутствует непосредственная поддержка атомарных
&laquo;групповых&raquo; блокировок.

<P>(На будущее в API заложена концепция "lockset_id", но в текущей
реализации она никак не используется.)

  <LI>При неудаче попытки наложения блокировки (например, если канал(ы) уже
заблокирован(ы) другими) повторных попыток наложения автоматически НЕ
производится.  Эта задача возлагается на саму клиентскую программу, могущую
повторять вызовы <CODE>cda_lock_chans()</CODE> в соответствии со своими
знаниями об управляемой установке (или по команде оператора).

<P>Однако в случае потери связи при последующем восстановлении соединения с
сервером для каналов, помеченных как &laquo;желательные для
блокирования&raquo;&nbsp;&#151; (т.е., для которых был вызов с кодом
<CODE>CX_LOCK_WRITE_SET</CODE>, но не было <CODE>CX_LOCK_WRITE_RLS</CODE>),
будет выполнена повторная попытка блокировки.

  </UL>


		<H3>Типа "руководства программиста"</H3>

<P>Ниже кратко описывается работа с блокировками посредством библиотеки cda.

			<H4>Динамическое управление блокировками</H4>

<P>Для установки и снятия блокировок следует использовать функцию

<PRE>
int            cda_lock_chans (int count, cda_dataref_t *refs,
                               int operation, int lockset_id);
</PRE>

<P>Здесь

  <UL TYPE=square>

  <LI><CODE>count</CODE> количество затрагиваемых каналов.

  <LI><CODE>refs[]</CODE> их список.

  <LI><CODE>operation</CODE> указывает действие:
<CODE>CX_LOCK_WRITE_SET</CODE>&nbsp;&#151; установка блокировки,
<CODE>CX_LOCK_WRITE_RLS</CODE>&nbsp;&#151; снятие.

  <LI><CODE>lockset_id</CODE> в настоящее время не используется;
рекомендуется указывать значение <CODE>0</CODE> для совместимости с будущими
реализациями.

  </UL>

<P>Замечания:

  <OL>

  <LI>Блокировку можно накладывать только на cda-объекты, являющиеся
каналами.  Для регистров и формул, являющихся локальными для программы
объектами, понятие блокировки бессмысленно и попытка указания таких
объектов в <CODE>cda_lock_chans()</CODE> приводит к ошибке с кодом
<CODE>EINVAL</CODE> и отклонению всего списка целиком.

  <LI>Каналы в одном вызове могут принадлежать разным серверам/соединениям
(и даже разным протоколам связи)&nbsp;&#151; cda сама обеспечивает
распределение запросов по соответствуюим соединениям.

  <LI>Однако блокировка должна поддерживаться в реализации всех участвующих
в запросе соединений, в противном случае запрос будет отклонён сразу с кодом
ошибки <CODE>EINVAL</CODE> и ни на один из каналов блокировка сделана не
будет.

<P>В настоящее время (май 2020г.) операция блокировки поддерживается в
протоколах <TT>cx::</TT> (CXv4) и <TT>insrv::</TT>.

  <LI>Следует помнить, что <CODE>cda_lock_chans()</CODE> не даёт
немедленного результата, а лишь посылает запрос серверу (причём, при
отсутствии соединения в текущий момент запрос будет отправлен позже, после
установления соединения).

  <LI>Однако конкретно в протоколе <TT>insrv::</TT> операция блокировки
является синхронной и результат определён сразу же по завершении вызова
<CODE>cda_lock_chans()</CODE> (точнее, даже ДО его завершения, поскольку
события LOCKSTAT генерируются внутри него).

  </OL>


			<H4>Блокировка канала при создании</H4>

<P>Можно указать необходимость блокировки канала сразу при создании, указав
флаг <CODE>CDA_DATAREF_OPT_EXCLUSIVE</CODE> в параметре
<CODE>options></CODE> <CODE>cda_add_chan()</CODE>.

<P>Это эквивалентно тому, как если сразу после создания канала сделать
запрос на установку блокировки.

<P>В дальнейшем блокировку можно снимать и устанавливать динамически обычным
образом.


			<H4>Слежение за состоянием блокировки</H4>

<P>Для слежения за состоянием блокировки следует мониторировать событие по
маске <CODE>CDA_REF_EVMASK_LOCKSTAT</CODE>.

  <UL TYPE=square>

  <LI>Код присылаемого события&nbsp;&#151;
<CODE>CDA_REF_R_LOCKSTAT</CODE>.

  <LI>Состояние блокировки передаётся обработчику события в параметре
<CODE>info_ptr</CODE>, для данного кода передающего целое число: 0
(NULL)&nbsp;&#151; потеря блокировки, 1 (в виде
<CODE>(void*)1</CODE>)&nbsp;&#151; получение блокировки.

  </UL>

<P>Библиотека cda гарантирует, что присылаются только события ИЗМЕНЕНИЯ
состояния блокировки.


			<H4>Проверка текущего состояния блокировки</H4>

<P>Текущее состояние блокировки (точнее, последнее состояние, известное cda)
можно узнать при помощи функции

<PRE>
int            cda_lock_stat_of_ref     (cda_dataref_t  ref);
</PRE>

<P>Возвращается <CODE>0</CODE> при отсутствии блокировки и <CODE>1</CODE>
при её установленности.


		<H3>Дополнительные особенности</H3>

			<H4>Блокировка устройств</H4>

<P>Наложение блокировки на канал <TT>_devstate</TT> приводит к блокировке
данного устройства целиком&nbsp;&#151; как если бы блокировка накладывалась
группой на все его каналы, включая и сам канал <TT>_devstate</TT> (но НЕ
включая канал <TT>_logmask</TT>).

<P>Соответственно, блокировка не может быть получена, если хотя бы один
канал устройства уже заблокирован кем-то другим.

<P>Для снятия блокировки достаточно вызвать снятие её с канала
<TT>_devstate</TT>.


</BODY>
</HTML>
