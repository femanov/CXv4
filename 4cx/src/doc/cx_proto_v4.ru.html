<HTML>
<HEAD>
<TITLE>CX-протокол версии 4</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="style.css">
</HEAD>
<BODY>

<H1>CX-протокол версии 4.</H1>


		<H2>Общие сведения.</H2>

<P>CX-протокол является транспортно-сеансовым протоколом системы
управления CX и реализует следующий функционал:

  <UL TYPE=square>

  <LI>Установление соединения, с контролем доступа и первоначальным
"договариванием" (handshake).

  <LI>Обслуживание информационной подсистемы: резолвинг имён каналов,
точек контроля и устройств, передачу их свойств (типы, коэффициенты
преобразования, диапазоны).  В том числе уведомления при смене этих
свойств.

  <LI>Передача данных системы управления.

  <LI>Взаимодействие по интерфейсу "удалённая консоль".

  </UL>

<P>Ключевые характеристики протокола:

  <UL TYPE=square>

  <LI>Протокол является потоковым (stream) и использует протоколы TCP и
UNIX/STREAM.

  <LI>На одном узле сети может быть запущено несколько серверов CX
одновременно, они различаются номерами и ссылки на сервера имеют вид
HOST:N.

  <LI>Для сервера номер N используется TCP-порт номер 8012+N и
unix-socket с именем <TT>/tmp/cxv4-N-socket</TT>.

  <LI>При первоначальном договаривании в момент установления соединения
клиент сообщает серверу свой порядок байт (endianness) и весь
дальнейший обмен производится сообщениями с порядком байт клиента.

  <LI>Сообщения протокола имеют контейнерную структуру: каждое
сообщение начинается с заголовка фиксированного размера 32 байта,
содержащего количество сегментов с данными и общий размер данных в
сообщении.

  <LI>Максимальный размер сообщения -- чуть менее 4Гб ((2^32)-32
байт), вследствие использования 32-битовых полей размера.  В настоящий
момент установлено дополнительное программное ограничение в 4Мб.

  <LI>Протокол использует как синхронную модель (запрос-ответ), так и
асинхронную: клиент запрашивает уведомления о неких событиях, сразу же
получает подтверждение о получении запроса, а сами уведомления приходят
потом по мере надобности.  Синхронные и асинхронные сообщения
используются вперемешку.

<P>Для простоты соотнесения асинхронных уведомлений с запросами, их
установившими, каждый пакет имеет в заголовке поле идентификационного
номера, устанавливаемого клиентом (уведомления имеют то же значение,
что в установившем их запросе).

  <LI>Для определения состояния соединения используются
KEEPALIVE-пакеты протокола TCP, а также "application pings".

  <LI>Реализация CX-протокола

(<A HREF="lib/cxlib.ru.html">cxlib</A>)

НЕ обеспечивает восстановление соединения при обрыве связи.  Это
возложено на библиотеку более высокого уровня

<A HREF="lib/cda.ru.html">cda</A>.

  </UL>


		<H2>Структура сообщений протокола.</H2>

<P>Структура протокола определяется файлом <TT>cx_proto_v4.h</TT>.


		<H3>Заголовок сообщения.</H3>

<P>Каждое сообщение начинается с заголовка фиксированного формата,
содержащего 8 полей типа uint32 (в сумме 32 байта), непосредственно за
ним могут идти данные ("полезная нагрузка").  Заголовок описывается
типом <CODE>CxV4Header</CODE> и имеет следующую структуру:

<SMALL><PRE>
+-0--------+-1--------+-2--------+-3--------+-4--------+-5--------+-6--------+-7--------+
| DataSize |   Type   |    ID    |    Seq   | NumChunks|  Status  |   var1   |   var2   |
+----------+----------+----------+----------+----------+----------+----------+----------+
</PRE></SMALL>

  <UL TYPE=square>

  <LI><CODE>DataSize</CODE> -- объём полезных данных в сообщении, в
байтах (НЕ включает размер заголовка!).

  <LI><CODE>Type</CODE> -- тип сообщения.  Одна из констант
<CODE>CXT4_nnn</CODE>.

  <LI><CODE>ID</CODE> -- идентификатор соединения.  Присваивается
сервером в момент установления соединения и должен присылаться клиентом
в каждом пакете.

  <LI><CODE>Seq</CODE> -- идентификационный номер сообщения. 
Устанавливается клиентом, сервер в ответных сообщениях присылает
значение, указанное в соответствующем пакете запроса.

  <LI><CODE>NumChunks</CODE> -- количество сегментов данных в пакете. 
Их суммарный объём должен соответствовать значению поля
<CODE>DataSize</CODE>.

  <LI><CODE>Status</CODE> -- статус исполнения запроса, имеет смысл
только в ответных пакетах.

  <LI><CODE>var1</CODE> -- зависит от типа сообщения.

  <LI><CODE>var2</CODE> -- зависит от типа сообщения.

  </UL>


		<H3>Заголовок сегмента.</H3>

<P>Каждый сегмент данных начинается с заголовка фиксированного формата,
содержащего 4 поля типа uint32 (в сумме 16 байт), непосредственно за
ним могут идти данные.  Заголовок сегмента описывается типом
<CODE>CxV4Chunk</CODE> и имеет следующую структуру:

<SMALL><PRE>
+-0--------+-1--------+-2--------+-3--------+
|  OpCode  | ByteSize |  param1  |  param2  |
+----------+----------+----------+----------+
</PRE></SMALL>

  <UL TYPE=square>

  <LI><CODE>OpCode</CODE> -- тип сегмента (код операции).

  <LI><CODE>ByteSize</CODE> -- размер сегмента в байтах (ВКЛЮЧАЯ размер
заголовка).

  <LI><CODE>param1</CODE> -- зависит от типа сегмента.

  <LI><CODE>param2</CODE> -- зависит от типа сегмента.

  </UL>


		<H3>Установление соединения.</H3>

<P>Установление соединения происходит в ??? шагов,

  <OL>

  <LI>Выполняется соединения на уровне сокетов -- выполнение системных
вызовов <CODE>connect()</CODE> клиентом и <CODE>accept()</CODE>
сервером.

  <LI>Клиент отправляет серверу свою сигнатуру: пакет с типом
<CODE>CXT4_ENDIANID</CODE>.  При этом в поле <CODE>var1</CODE>
записывается сигнатура 0x12345678
(<CODE>CXV4_VAR1_ENDIANNESS_SIG</CODE>), а в поле <CODE>var2</CODE>
поддерживаемая клиентом версия CX-протокола (на 22.11.2013 -- 4.0.0.0),
упакованная по схеме

<BLOCKQUOTE><I>MAJOR*10000000 + MINOR*100000 + PATCHLEVEL*1000 + SNAPSHOT</I></BLOCKQUOTE>

(эта схема определена в <TT>cx_version.h</TT>).

  <LI>Сервер, проанализировав сигнатуру клиента, при удовлетворённости
ею отвечает пакетом с типом <CODE>CXT4_LOGIN</CODE>.  В поле
<CODE>ID</CODE> присылается присвоенный сервером идентификатор клиента,
а в поле <CODE>var2</CODE> -- версия протокола, поддерживаемая
сервером.

<P>В случае ошибки сервер присылает соответствующий пакет с кодом
ошибки (неизвестный порядок байт -- <CODE>CXT4_EINVAL</CODE>,
неподдерживаемая версия протокола -- <CODE>CXT4_DIFFPROTO</CODE>) и
закрывает соединение.

  <LI>Клиент "выполняет вход на сервер", присылая пакет с типом
<CODE>CXT4_LOGIN</CODE>.  Этот пакет должен содержать ровно 1 сегмент с
типом <CODE>CX4_OC_LOGIN</CODE> и размером 96 байт.  Формат этого
сегмента описывается типом <CODE>CxV4LoginRec</CODE> и имеет следующую
структуру:

<SMALL><PRE>
+-0...15---+-16...55--+-56...95--+
| CxV4Chunk| progname | username |
+----------+----------+----------+
</PRE></SMALL>

    <UL TYPE=square>
  
    <LI>Вначале идёт стандартный заголовок сегмента.
  
    <LI><CODE>progname</CODE> -- имя программы (финальная часть
<CODE>argv[0]</CODE> или <CODE>program_invocation_short_name</CODE>).

    <LI><CODE>username</CODE> -- имя пользователя (обычно значение
переменной окружения <CODE>$LOGNAME</CODE>).
  
    </UL>

<P>Поля <CODE>progname</CODE> и <CODE>username</CODE> имеют размер 40
символов, байты после значащих символов заполняются нулями.

  <LI>

  <LI>

  </OL>

<P>После присылки клиентом пакета <CODE>CXT4_ENDIANID</CODE> весь обмен
ведётся в порядке байт клиента.  Возможность же присыдки самого этого
пакета (и вообще простейшего обмена пакетами еще ДО договаривания о
порядке байт) обеспечивается двумя техническими решениями:

  <OL>

  <LI>В поле <CODE>DataSize</CODE> не учитывается размер самого
заголовка.  Таким образом, для пакетов без данных там содержится 0, чьё
представление одинаково при любом порядке байт.

  <LI>Коды некоторых типов пакетов (включая <CODE>CXT4_ENDIANID</CODE>
и коды ошибок) имеют вид <I>N*0x01010101</I> -- т.е., все байты в них
одинаковые и проблема порядка байт не стоит.

  </OL>


		<H3>Application-level pings (keepalives)</H3>

<P>При установлении соединения по TCP обе стороны (и клиент, и сервер)
включают socket-опцию <CODE>SO_KEEPALIVE</CODE> для обнаружения обрывов
соединения при неактивности (например, если с одним из узлов сети
потеряна связь или он был аппаратно перегружен без корректного
завершения работы).

<P>Однако в этом случае обрывы обнаруживаются через долгое время (в
Linux по умолчанию период 7200 секунд).  Для обхода этой проблемы
протокол поддерживает т.н. "application-level pings" (они же
"application-level keepalives") -- пакеты, на которые единственной
реакцией должна быть отправка обратного пустого пакета.

<P>При этом собственно обнаружение обрыва соединений по-прежнему
выполняется ядром ОС (а не прикладным уровнем), просто сама отправка
пакета приводит к обмену данными по TCP, который в противном случае
происходил бы раз в 7200 секунд.  Обычно такие пакеты отправляются раз
в 300 секунд, что значительно повышает скорость обнаружения обрывов.

<P>Пакет "ping" имеет код <CODE>CXT4_PING</CODE>, а обратный пакет
"pong" -- <CODE>CXT4_PONG</CODE> (на него вообще никакая реакция не
требуется).


</BODY>
</HTML>
