<HTML>
<HEAD>
<TITLE>Драйверный API CX-сервера (cxsd_driver)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.css">
</HEAD>
<BODY>

<H1>Драйверный API CX-сервера (cxsd_driver) -- руководство программиста</H1>


	<H2>Введение</H2>

<P>Драйверный API CX-сервера определяется в файле <TT>cxsd_driver.h</TT>.

<P>Определяется именно ИНТЕРФЕЙС, реализации же -- "среды исполнения
драйверов" -- могут быть и разными и реализовывать лишь основной функционал,
без дополнительных сервисов.

<P>В настоящий момент (07.11.2016) существует 2 реализации:

  <DL>

  <DT>Серверная</DT><DD>Собственно CX-сервер -- программы
<CODE>cx-server</CODE> и <CODE>stand</CODE>, построенные на основе
библиотеки <TT>libcxsd.a</TT>.

    <UL TYPE=square>

    <LI>Скомпилированные драйверы являются динамически загружаемыми модулями
(<TT>ИМЯ_ДРАЙВЕРА_drv.so</TT>), подгружаемыми CX-сервером по мере
надобности.

<P STYLE="font-size: smaller;">Соответственно, ошибки вроде "ненайденных
символов" обнаруживаются лишь в момент загрузки.

    <LI>В дополнение к основному функционалу предоставляется библиотеки
<CODE>cda</CODE> (для возможности взаимодействия с другими драйверами,
подробнее см.

<A HREF="vdev.ru.html")>vdev</A>), <CODE>cxscheduler</CODE> и
<CODE>fdiolib</CODE>.

    </UL>

</DD>

  <DT>Удалённая</DT><DD>Среды удалённых драйверов --

    <OL TYPE=a>

    <LI>cерверы для CANGW, Moxa UC-7112, построенные на основе библиотеки
<TT>libremsrv.a</TT>;

    <LI>отдельные драйвлеты, построенные на основе библиотеки
<TT>libremdrvlet.a</TT>.

    </OL>

<P>В обоих случаях:

    <UL TYPE=square>

    <LI>Драйверы при сборке статически влинковываются непосредственно в
исполняемые файлы (<TT>v4c4lcanserver</TT> для CANGW,
<TT>cxv4moxaserver</TT> для UC-7112, <TT>cm5307_ИМЯ_ДРАЙВЕРА.drvlet</TT> для
CM5307/PPC).

<P STYLE="font-size: smaller;">Соответственно, все ошибки обнаруживаются
прямо в процессе сборки.

    <LI>Библиотеки <CODE>cxscheduler</CODE> и <CODE>fdiolib</CODE> также
предоставляются, но взаимодействие с другими драйверами и серверами
недоступно.

    </UL>

</DD>

  </DL>

<P>В будущем могут созданы еще среды исполнения -- например, встраиваемая в
специализированный сервер непосредственно в управляющем микроконтроллере
(Raspberry PI, CompactRIO, ...), с другим набором предоставляемых библиотек.

<P>Корректно написанный драйвер -- т.е., использующий только минимально
необходимый для его работы функционал -- будет корректно собираться и работать
с любой из сред исполнения.


	<H2>Обзор</H2>

<P>Драйверный API состоит из двух взаимодополняющих частей:

  <OL>

  <LI>Собственно API -- набор функций, доступных драйверам.

  <LI>"Методы" драйвера, при помощи которых драйвер интегрируется в сервер.

<P>Таблица методов драйвера содержится в структуре-описателе, заполняемой
макросом <CODE>DEFINE_CXSD_DRIVER()</CODE>.

<P>В этой же структуре содержится информация, необходимая для динамической
загрузки драйвера.

  </OL>

<P>Общая схема взаимодействия сервер&lt;-&gt;драйвер при передаче данных --
асинхронная, такая же, как и схема взаимодействия клиент&lt;-&gt;сервер:

  <UL TYPE=square>

  <LI>Когда сервер должен передать драйверу запрос на чтение или запись
каналов, то он вызывает соответствующий метод драйвера, и на этом всё --
сервер не ждёт ответа, а продолжает работу.

  <LI>Когда у драйвера готов ответ, то он вызывает функцию "вернуть данные".

<P>Это может быть как ответ на запрос сервера (в т.ч. "вернуть данные" можно
непосредственно из метода, вызванного сервером), так и передача данных по
собственной инициативе драйвера (примеры второго приведены в разделе 

"<A HREF="#rules_drivers">Некоторые принятые правила: Поведение
драйверов</A>").

  </UL>


	<H2>Описатель драйвера</H2>

<P>Информацию из таблицы-описателя динамически-загружаемых драйверов можно
посмотреть из командной строки при помощи утилиты <CODE>drvinfo</CODE>.


	<H2>API для драйверов</H2>


	<H2>Некоторые принятые правила</H2>

		<H3>Поведение сервера</H3>

<P>Ниже перечислены некоторые особенности функционирования CX-сервера,
которые хоть формально и не гарантируются, но существуют де-факто и их
знание может помочь при создании и отладке драйверов.

  <DL>

  <DT>Канал не запрашивается более чем единожды.</DT><DD>Пока не придёт
ответ, более запроса не будет.

<P>Однако при переходе устройства в состояние OPERATING запрос будет
повторён.</DD>

  <DT>Каналы чтения не запрашиваются чаще, чем раз в цикл.</DT><DD>В случае
прихода запроса на чтение канала, который в текущем цикле уже вычитывался,
повторного запроса на чтение прислано не будет.

<P>Однако клиенты могут изменять это поведение, указывая флаг
<CODE>CDA_DATAREF_OPT_ON_UPDATE</CODE>.</DD>

  <DT>Из множественных запросов на запись исполняется последний.</DT><DD>При
втором запросе от клиента на запись (и последующих запросах) до получения
ответа на предыдущий, последний из запросов будет запомнен и отправлен сразу
после получения ответа.

<P>Точнее, запоминаются все запросы, но каждый следующий запоминается поверх
предыдущего, замещая его значение.</DD>

  <DT>Запросы клиентов на чтение каналов записи драйверам не
передаются.</DT><DD>Предполагается, что однажды уставленное в канал записи
значение останется там "навечно".  Поэтому запросы клиентов на чтение
каналов записи сервер удовлетворяет из своего "кэша", не передавая их
драйверам.

<P>Если драйвер меняет значение такого канала по собственной инициативе
(например, канал-alias), то он <B>должен</B> сразу прислать серверу новое
значение и тогда оно будет запомнено в качестве "авторитетного".

<P>Например, так делается для каналов-представлений выходных регистров,
8-битового и 8 штук по 1 биту: при записи в любой битовый канал меняется
значение 8-битового, а при записи в 8-битовый меняются значения всех
битовых.</DD>

  <DT>Каналы записи автоматом запрашиваются при переходе в
OPERATING.</DT><DD>Следствие из предыдущего пункта: чтобы всегда иметь
актуальные значения, при "оживании" устройства сервер запрашивает текущие
значения ВСЕХ его каналов записи.</DD>

  <DT>При переходе в OPERATING неисполненные запросы
повторяются.</DT><DD>При переходе в состояние OPERATING -- т.е., при
"оживании" устройства -- сервер повторно присылает все запросы как на
чтение, так и на запись.</DD>

  </DL>


		<H3 ID="rules_drivers">Поведение драйверов</H3>

<P>Ниже приведены сценарии, когда драйвер может отсылать данные серверу по
собственной инициативе (список НЕ исчерпывающий).

  <UL TYPE=square>

  <LI>Отсроченный возврат: когда ответ готов через большой промежуток
времени.

<P>Например, устройства, подключенные по медленной последовательной шине;
АЦП с долгим интегрированием, ...

  <LI>Много "ответов" без запроса.  Например,

    <OL TYPE=a>

    <LI>При циклическом опросе (так работают многие CAN-АЦП).

    <LI>При измерениях по внешнему запуску.

    </OL>

<P>В этих случаях драйверу имеет смысл пометить такие каналы как
AUTOUPDATED.

  <LI>Возврат "статичных" данных, которые никогда не будут меняться.

<P>Например, серийный номер модуля или версия прошивки.

<P>В этом случае также следует пометить такие каналы как AUTOUPDATED, причём
ДО возврата значений.

  <LI>Возврат каналов записи при их изменении.

<P>Например, биты выходного регистра, имеющие разные каналы-представления
(8-битовый канал и 8 штук 1-битовых) -- при записи в одно представление
нужно отразить изменения в другом. 

  <LI>Нет ответа вообще -- также вполне легитимно.

<P>Драйвер может не давать ответа на неподдерживаемые каналы, а также на
временно неготовые (например, нет связи с удалённым устройством).

  </UL>


	<H2></H2>


</BODY>
</HTML>
