<HTML>
<HEAD>
<TITLE>Библиотека vdev</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.css">
</HEAD>
<BODY>

<H1>Библиотека vdev&nbsp;&#151; руководство программиста</H1>

	<H2>Введение</H2>

		<H3>Потребность</H3>

<P>Библиотека <CODE>vdev</CODE> (Virtual DEVice) предназначена для создания
драйверов CX-сервера, работающих с аппаратурой не напрямую, а через другие
драйверы.

<P>Выбор названия обусловлен тем, что подобные драйверы представляют как бы
"виртуальные" устройства, не существующие как управляющие устройства
напрямую, а управляемые другими устройствами <I>(сумбурное объяснение,
да...)</I>.

<P>Примеры подобных устройств:

  <UL TYPE=square>

  <LI><CODE>ist_cdac20</CODE>: источники ИСТ, ИСТР и совместимые.
Управляются через встраиваемый в них CDAC20 либо CEAC51.

  <LI><CODE>v3h_a40d16</CODE>: источники ВЧ300.  Комплект из 8 источников
управляется связкой CANDAC16 плюс CANADC40.

  <LI><CODE>vepp4_gimn</CODE>: ГИМН, стоящий во впуске из канала К500 в
ВЭПП-3М.  Управляется связкой CGVI8M с CPKS8, плюс VsDC2 (итого 3
устройства).

  </UL>

		<H3>Смысл существования vdev</H3>

  <UL TYPE=square>

  <LI>В принципе, возможно было бы вставлять специфику работы с реальными
управляющими устройствами прямо в драйверы "виртуальных устройств".  Но это:

    <OL TYPE=a>

    <LI>Является дублированием кода.

    <LI>Очень неудобно, поскольку работа с некоторыми устройствами весьма
нетривиальна и смешивание её с логикой работы "виртуальных устройств"
создало бы крайне плохо поддерживаемый спагетти-код.

    </OL>

  <LI>Дополнительный плюс отделения "виртуальных" устройств от реальных --
независимость и, как следствие, гибкость:

    <UL TYPE=square>

    <LI>Несколько виртуальных устройств могут пользоваться одним реальным,
не создавая конфликтов (поскольку реально с устройством будет работать
один-единственный драйвер).

    <LI>Одно виртуальное устройство может быть составлено из нескольких
реальных.

    <LI>Вследствие использования cda, виртуальное устройство в одном сервере
может пользоваться реальными устройствами другого сервера (в т.ч.
запущенного на другом хосте).

    </UL>

  <LI>Хотя поддерживать взаимодействие с подчинёнными устройствами можно и
напрямую через cda, но соответствующий код содержит большое количество
стандартных "ритуальных заклинаний" и, воизбежание дублирования, прекрасно
обобщается.

<P>Экспериментальная проверка -- на драйвере
<CODE>lebedev_subharmonic</CODE>, не использующем машину состояния --
показала, что при переводе на vdev код сократился на 35 строк.

  </UL>

		<H3>Состав</H3>

<P>Библиотека состоит из 2 частей:

  <OL>

  <LI>"Наблюдатель" (observer).  Поддерживает связь с подчинёнными
устройствами: получает значения их каналов, а также следит за их состоянием
(через

<A HREF="../_devstate.ru.html">каналы <TT>._devstate</TT></A>).

  <LI>Машина состояний.  Предоставляет реализацию специализированной машины
состояний, позволяющую отразить логику функционирования обслуживаемых
устройств (многие из них хорошо описываются в терминах машин состояний).

  </OL>

<P>Observer может использоваться самостоятельно, а машина состояний
пользуется observer'ом.

		<H3>Специфика реализации</H3>

  <UL TYPE=square>

  <LI>Взаимодействие с реальными устройствами производится через cda, по
протоколу <TT>insrv::</TT>.

  <LI>При указании в качестве базового устройства имени с префиксом
<TT>cx::</TT> можно использовать устройство из другого сервера.

<P>Причём это делается прозрачно для драйвера виртуального устройства,
просто соответствующим указанием в devlist-файле.

  <LI STYLE="font-size: smaller;">Также можно создавать многоуровневые
иерархии из виртуальных устройств, но на текущий момент (03.11.2016) таких
потребностей не возникало.

  </UL>

		<H3>Терминология</H3>

<P>Далее в тексте (и в самой библиотеке <CODE>vdev</CODE>) используются
следующие термины:

  <DL>

  <DT>Контекст</DT><DD>Структура (типа <CODE>vdev_context_t</CODE>),
определяющая текущее состояние библиотеки и хранящая всю информацию для
неё.

<P>Контекст аллокируется драйвером виртуального устройства.

</DD>

  <DT>Подчинённое устройство</DT><DD>(Subordinate device) -- реальное
устройство (или устройствА), через которое драйвер виртуального устройства
общается с аппаратурой.</DD>

  <DT>sodc</DT><DD>(SubOrDinate Channel) -- канал подчинённого устройства,
номер.

<P>Драйвер виртуального устройства создаёт свою "карту" каналов подчинённого
устройства, адресуемую по номерам, по которым и идёт всё взаимодействие в
рамках vdev.

<P>Эта нумерация может и совпадать с нумерацией каналов реального целевого
устройства (определяемой в его <TT>_drv_i.h</TT>-файле), но глубокого смысла
в этом нет (особенно при использовании множественных подчинённых устройств)
и на текущий момент (03.11.2016) все драйверы-пользователи vdev имеют
собственные карты, содержащие лишь требуемые им каналы.

</DD>

  <DT>ourc</DT><DD>(OUR Channel) -- "наш канал", номер канала виртуального
устройства.</DD>

  <DT></DT><DD></DD>

  </DL>


	<H2></H2>


	<H2>ZZZZZZZZZZ</H2>

<P>У каждого состояния может быть функция, вызываемая по его активации
(например, для состояния "Включиться" -- эта функция может выставить
единичку в бит включения).

<P>Переходы между состояниями могут происходить по внешней команде
(например, "Включиться"), по значениям каналов подчинённых устройств
(например, "Блокировка"), по времени (например, после включения нужно
подождать полторы секунды перед заданием тока), либо автоматически (после
перехода в состояние X сразу делается переход в состояние Y).


	<H2></H2>


	<H2></H2>


</BODY>
</HTML>
